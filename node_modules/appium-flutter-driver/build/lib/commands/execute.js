"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = void 0;
const session_1 = require("../sessions/session");
const scroll_1 = require("./execute/scroll");
const wait_1 = require("./execute/wait");
const app_1 = require("./../ios/app");
const bluebird_1 = __importDefault(require("bluebird"));
const flutterCommandRegex = /^[\s]*flutter[\s]*:(.+)/;
const execute = async function (rawCommand, args) {
    // flutter
    const matching = rawCommand.match(flutterCommandRegex);
    if (!matching) {
        throw new Error(`Command not support: "${rawCommand}"`);
    }
    const command = matching[1].trim();
    switch (command) {
        case `launchApp`:
            return await flutterLaunchApp(this, args[0], args[1]);
        case `connectObservatoryWsUrl`:
            return await connectObservatoryWsUrl(this);
        case `getVMInfo`:
            return await getVMInfo(this);
        case `setIsolateId`:
            return await setIsolateId(this, args[0]);
        case `getIsolate`:
            return await getIsolate(this, args[0]);
        case `checkHealth`:
            return await checkHealth(this);
        case `clearTimeline`:
            return await clearTimeline(this);
        case `forceGC`:
            return await forceGC(this);
        case `getRenderTree`:
            return await getRenderTree(this);
        case `getBottomLeft`:
            return await getOffset(this, args[0], { offsetType: `bottomLeft` });
        case `getBottomRight`:
            return await getOffset(this, args[0], { offsetType: `bottomRight` });
        case `getCenter`:
            return await getOffset(this, args[0], { offsetType: `center` });
        case `getTopLeft`:
            return await getOffset(this, args[0], { offsetType: `topLeft` });
        case `getTopRight`:
            return await getOffset(this, args[0], { offsetType: `topRight` });
        case `getRenderObjectDiagnostics`:
            return await getRenderObjectDiagnostics(this, args[0], args[1]);
        case `getSemanticsId`:
            return await getSemanticsId(this, args[0]);
        case `waitForAbsent`:
            return await (0, wait_1.waitForAbsent)(this, args[0], args[1]);
        case `waitFor`:
            return await (0, wait_1.waitFor)(this, args[0], args[1]);
        case `waitForTappable`:
            return await (0, wait_1.waitForTappable)(this, args[0], args[1]);
        case `scroll`:
            return await (0, scroll_1.scroll)(this, args[0], args[1]);
        case `scrollUntilVisible`:
            return await (0, scroll_1.scrollUntilVisible)(this, args[0], args[1]);
        case `scrollUntilTapable`:
            return await (0, scroll_1.scrollUntilTapable)(this, args[0], args[1]);
        case `scrollIntoView`:
            return await (0, scroll_1.scrollIntoView)(this, args[0], args[1]);
        case `setTextEntryEmulation`:
            return await setTextEntryEmulation(this, args[0]);
        case `enterText`:
            return await enterText(this, args[0]);
        case `requestData`:
            return await requestData(this, args[0]);
        case `longTap`:
            return await (0, scroll_1.longTap)(this, args[0], args[1]);
        case `waitForFirstFrame`:
            return await waitForCondition(this, { conditionName: `FirstFrameRasterizedCondition` });
        case `setFrameSync`:
            return await setFrameSync(this, args[0], args[1]);
        case `clickElement`:
            return await clickElement(this, args[0], args[1]);
        default:
            throw new Error(`Command not support: "${rawCommand}"`);
    }
};
exports.execute = execute;
const flutterLaunchApp = async (self, appId, opts) => {
    const { arguments: args = [], environment: env = {} } = opts;
    await (0, app_1.launchApp)(self.internalCaps.udid, appId, args, env);
    await session_1.reConnectFlutterDriver.bind(self)(self.internalCaps);
};
const connectObservatoryWsUrl = async (self) => {
    await session_1.reConnectFlutterDriver.bind(self)(self.internalCaps);
};
const checkHealth = async (self) => (await self.executeElementCommand(`get_health`)).status;
const getVMInfo = async (self) => (await self.executeGetVMCommand());
const getRenderTree = async (self) => (await self.executeElementCommand(`get_render_tree`)).tree;
const getOffset = async (self, elementBase64, offsetType) => await self.executeElementCommand(`get_offset`, elementBase64, offsetType);
const waitForCondition = async (self, conditionName) => await self.executeElementCommand(`waitForCondition`, ``, conditionName);
const forceGC = async (self) => {
    const response = await self.socket.call(`_collectAllGarbage`, {
        isolateId: self.socket.isolateId,
    });
    if (response.type !== `Success`) {
        throw new Error(`Could not forceGC, response was ${response}`);
    }
};
const setIsolateId = async (self, isolateId) => {
    self.socket.isolateId = isolateId;
    return await self.socket.call(`getIsolate`, {
        isolateId: `${isolateId}`,
    });
};
const getIsolate = async (self, isolateId) => await self.executeGetIsolateCommand(isolateId || self.socket.isolateId);
const clearTimeline = async (self) => {
    // @todo backward compatible, need to cleanup later
    const call1 = self.socket.call(`_clearVMTimeline`);
    const call2 = self.socket.call(`clearVMTimeline`);
    const response = await bluebird_1.default.any([call1, call2]);
    if (response.type !== `Success`) {
        throw new Error(`Could not forceGC, response was ${response}`);
    }
};
const getRenderObjectDiagnostics = async (self, elementBase64, opts) => {
    const { subtreeDepth = 0, includeProperties = true } = opts;
    return await self.executeElementCommand(`get_diagnostics_tree`, elementBase64, {
        diagnosticsType: `renderObject`,
        includeProperties,
        subtreeDepth,
    });
};
const getSemanticsId = async (self, elementBase64) => (await self.executeElementCommand(`get_semantics_id`, elementBase64)).id;
const enterText = async (self, text) => await self.socket.executeSocketCommand({ command: `enter_text`, text });
const requestData = async (self, message) => await self.socket.executeSocketCommand({ command: `request_data`, message });
const setFrameSync = async (self, bool, durationMilliseconds) => await self.socket.executeSocketCommand({
    command: `set_frame_sync`,
    enabled: bool,
    timeout: durationMilliseconds,
});
const setTextEntryEmulation = async (self, enabled) => await self.socket.executeSocketCommand({ command: `set_text_entry_emulation`, enabled });
const clickElement = async (self, elementBase64, opts) => {
    const { timeout = 1000 } = opts;
    return await self.executeElementCommand(`tap`, elementBase64, {
        timeout
    });
};
//# sourceMappingURL=execute.js.map