"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getObservatoryWsUri = exports.connectIOSSession = exports.startIOSSession = void 0;
const appium_ios_device_1 = require("appium-ios-device");
const appium_xcuitest_driver_1 = __importDefault(require("appium-xcuitest-driver"));
const bluebird_1 = __importDefault(require("bluebird"));
const net_1 = __importDefault(require("net"));
const portscanner_1 = require("portscanner");
const logger_1 = require("../logger");
const observatory_1 = require("./observatory");
const LOCALHOST = `127.0.0.1`;
const setupNewIOSDriver = async (...args) => {
    const iosdriver = new appium_xcuitest_driver_1.default({});
    await iosdriver.createSession(...args);
    return iosdriver;
};
const startIOSSession = async (flutterDriver, caps, ...args) => {
    logger_1.log.info(`Starting an IOS proxy session`);
    const iosdriver = await setupNewIOSDriver(...args);
    // the session starts without any apps
    if (caps.app === undefined && caps.bundleId === undefined) {
        return [iosdriver, null];
    }
    return [
        iosdriver,
        await (0, observatory_1.connectSocket)(exports.getObservatoryWsUri, flutterDriver, iosdriver, caps),
    ];
};
exports.startIOSSession = startIOSSession;
const connectIOSSession = async (flutterDriver, iosdriver, caps) => await (0, observatory_1.connectSocket)(exports.getObservatoryWsUri, flutterDriver, iosdriver, caps);
exports.connectIOSSession = connectIOSSession;
async function requireFreePort(port) {
    if ((await (0, portscanner_1.checkPortStatus)(port, LOCALHOST)) !== `open`) {
        return;
    }
    logger_1.log.warn(`Port #${port} is busy. Did you quit the previous driver session(s) properly?`);
    throw new Error(`The port :${port} is occupied by an other process. ` +
        `You can either quit that process or select another free port.`);
}
const getObservatoryWsUri = async (flutterDriver, proxydriver, caps) => {
    let urlObject;
    if (caps.observatoryWsUri) {
        urlObject = new URL(caps.observatoryWsUri);
        urlObject.protocol = `ws`;
        // defaults to skip the port-forwarding as backward compatibility
        if (caps.skipPortForward === undefined || caps.skipPortForward) {
            return urlObject.toJSON();
        }
    }
    else {
        urlObject = (0, observatory_1.fetchObservatoryUrl)(proxydriver.logs.syslog.logs);
    }
    if (!proxydriver.isRealDevice()) {
        logger_1.log.info(`Running on iOS simulator`);
        return urlObject.toJSON();
    }
    const remotePort = urlObject.port;
    const localPort = caps.forwardingPort ?? remotePort;
    urlObject.port = localPort;
    logger_1.log.info(`Running on iOS real device`);
    const { udid } = proxydriver.opts;
    await requireFreePort(localPort);
    flutterDriver.localServer = net_1.default.createServer(async (localSocket) => {
        let remoteSocket;
        try {
            remoteSocket = await appium_ios_device_1.utilities.connectPort(udid, remotePort);
        }
        catch (e) {
            localSocket.destroy();
            return;
        }
        const destroyCommChannel = () => {
            remoteSocket.unpipe(localSocket);
            localSocket.unpipe(remoteSocket);
        };
        remoteSocket.once(`close`, () => {
            destroyCommChannel();
            localSocket.destroy();
        });
        remoteSocket.on('error', (e) => logger_1.log.debug(e));
        localSocket.once(`end`, destroyCommChannel);
        localSocket.once(`close`, () => {
            destroyCommChannel();
            remoteSocket.destroy();
        });
        localSocket.on('error', (e) => logger_1.log.warn(e.message));
        localSocket.pipe(remoteSocket);
        remoteSocket.pipe(localSocket);
    });
    const listeningPromise = new bluebird_1.default((resolve, reject) => {
        flutterDriver.localServer?.once(`listening`, resolve);
        flutterDriver.localServer?.once(`error`, reject);
    });
    flutterDriver.localServer?.listen(localPort);
    try {
        await listeningPromise;
    }
    catch (e) {
        flutterDriver.localServer = null;
        throw new Error(`Cannot listen on the local port ${localPort}. Original error: ${e.message}`);
    }
    logger_1.log.info(`Forwarding the remote port ${remotePort} to the local port ${localPort}`);
    process.on(`beforeExit`, () => {
        flutterDriver.localServer?.close();
        flutterDriver.localServer = null;
    });
    return urlObject.toJSON();
};
exports.getObservatoryWsUri = getObservatoryWsUri;
//# sourceMappingURL=ios.js.map